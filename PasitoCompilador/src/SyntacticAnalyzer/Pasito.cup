package SyntacticAnalyzer;

import java.io.FileInputStream;
import LexicalAnalyzer.LexicalAnalyzer;
import java.io.IOException;
import java.nio.file.Paths;
import java_cup.runtime.*;
import java.io.File;
import java.util.*;

//Importes das classses abstratas
import pasito.ast.Program;
import pasito.ast.declaration.*;
import pasito.ast.expression.*;
import pasito.ast.methodSpecOrInterfaceName.*;
import pasito.ast.signature.*;
import pasito.ast.statement.*;
import pasito.ast.topLevelDecl.*;
import pasito.ast.type.*;
// 

parser code {:
  protected LexicalAnalyzer lexer; // cria objeto LexicalAnalyzer (classe criada pelo JFlex com os automatos)
  :};

init with {:
    ComplexSymbolFactory f = new ComplexSymbolFactory(); // cria instância do ComplexSymbolFactory
    symbolFactory = f;	
 	 File file = new File("Teste.Pasito");
 	 FileInputStream fis = null;
  try {
    fis = new FileInputStream(file);
  } catch (IOException e) {
    e.printStackTrace();
  } 
/*
    File file = new File(Paths.get("").toAbsolutePath().toString() + "/Files4Test/" + "entrada-completa.pas"); // fazendo ler direto o arquivo de entrada em Pasito
    FileInputStream fis = null;
    try {
        fis = new FileInputStream(file);
    } catch (IOException e) {
        e.printStackTrace();
    }*/
    lexer = new LexicalAnalyzer(f,fis); // chamando construtor do LexicalAnalyzer com symbolFactory e arquivo de entrada em pasito
:};

scan with {:
    return lexer.next_token(); // chama próximo token
:};

/* @@@@@@@@@@@@ terminais (tokens retornados pelo analisador léxico, utilizados para criar classe Symbol) @@@@@@@@@@@@ */
terminal String ID;
terminal DEFAULT, FUNC, INTERFACE,FALLTHROUGH, CASE, STRUCT, TYPE, ELSE, SWITCH, IF, CONST, VAR;
terminal FOR, RETURN, RANGE;
terminal BOOLEAN, TRUE, FALSE, INT32, FLOAT64;
terminal Integer INT_NUMBER, NUMBER;
terminal Float FLOAT_NUMBER;
terminal PLUS, MINUS, TIMES, DIV, AND, EQ, NOT;
terminal LPAR, RPAR, LT, LSBRACK, RSBRACK, LBRACK,
         RBRACK, ASSIGN, DASSIGN, COMMA, SEMICOLON, EXCL, DOTDOTDOT, COLON, DOT;

non terminal Program Program;
non terminal List<TopLevelDecl> TopLevelDecl;
non terminal List<Declaration> Declaration;
non terminal List<TopLevelDecl> FunctionDecl; 
non terminal List<TopLevelDecl> MethodDecl; 
non terminal List<ConstDecl> ConstDecl; 
non terminal List<VarDecl> VarDecl;
non terminal List<TypeDecl> TypeDecl;
non terminal Type Type;
non terminal List<TypeDecl> TypeSpecList;
non terminal Type TypeLit;
non terminal ArrayType ArrayType;
non terminal StructType StructType;
non terminal SliceType SliceType;
non terminal FieldDecl;
non terminal FieldDeclList;
non terminal List<MethodSpec> MethodSpecList;
non terminal MethodSpec MethodSpec;
non terminal Signature Signature; 
non terminal Parameters;
non terminal Resul;
non terminal ParameterList;
non terminal ParameterDeclList;
non terminal TypeList;
non terminal Types;
non terminal List<String> IdentifierList;
non terminal Expression;
non terminal List<Expression> ExpressionList;
non terminal CompExpression;
non terminal AddExpression;
non terminal MultExpression;
non terminal UnaryExpr;
non terminal unary_op;
non terminal PrimaryExpr;
non terminal Slice;
non terminal Arguments;
non terminal Args;
non terminal VariadicCommaOp;
non terminal Operand;
non terminal CompositeLit;
non terminal Function;
non terminal MethodExpr;
non terminal LiteralType;
non terminal LiteralValue;
non terminal ReceiverType;
non terminal Element;
non terminal ElementList;
non terminal KeyedElement;
non terminal List<VarDecl> VarSpec; 
non terminal List<VarDecl> VarSpecList;
non terminal Block;
non terminal Statement;
non terminal StatementList;
non terminal SimpleStmt;
non terminal ForStmt;
non terminal IfStmt;
non terminal ElseOpt;

/* Precedences */
precedence left AND;
precedence left LT, EQ;
precedence left PLUS, MINUS;
precedence left TIMES, DIV;

Program ::= TopLevelDecl  : topDecs SEMICOLON Program : prog
             {: prog.declarations.addAll(0,topDecs);
              RESULT = prog; :}
		  |  {: RESULT = new Program(new LinkedList<>()); :} 
		    ;
			
TopLevelDecl ::=  Declaration  : decl
				{: 
					List<TopLevelDecl> tld = new LinkedList<>();
                    for (Declaration d : decl)
						tld.add(new Dec(d));
					RESULT = tld; 
				:} 
				| FunctionDecl : func
				 {: RESULT  = func; :}
				| MethodDecl  : method
				 {: RESULT  = method; :} 
				;

Declaration ::= ConstDecl  : constDecl	
			   {: 				
					List<Declaration> dec = new LinkedList<>();
					for(Declaration c: constDecl)
						dec.add(c);
				RESULT = dec;
			  :}		 
			  | VarDecl : varDecl
			  {:
					List<Declaration> dec = new LinkedList<>();
					for(Declaration v: varDecl)
						dec.add(v);
					RESULT = dec;
			  :}
			  | TypeDecl : typeDecl 
			  {:	
					List<Declaration> dec = new LinkedList<>();
					for(Declaration d: typeDecl)
						dec.add(d);
					RESULT = dec; 					
			  :}
			  ;

TypeDecl ::= TYPE ID:nm Type :type
			{: 	
				List<TypeDecl> td = new LinkedList<>(); 
				td.add(new TypeDecl(nm, type));						
				RESULT = td;	
			:}
				
           | TYPE LPAR TypeSpecList : typeDecls RPAR
           {:				   				
			   RESULT = typeDecls;	 
			:} 
           ;

TypeSpecList ::=  ID:nm Type : type SEMICOLON TypeSpecList  : tyDecs
				{:					
					tyDecs.add(0, new TypeDecl(nm, type));
					RESULT = tyDecs;
					
				:}
				| {: RESULT = new LinkedList<>(); :}
				;

Type ::=  ID : id {: RESULT = new TypeName(id); :}
		| TypeLit : Tlit
		{:
			RESULT = Tlit; // verificar o retorno de Type e TypeLit
		:}
		;

TypeLit ::= ArrayType : array
			{: RESULT =  array;	:}
		  | StructType : struct
		  {: RESULT = struct; :}
		  | TIMES Type : type
		  {: RESULT = type; :}
		  | INTERFACE LBRACK MethodSpecList : method RBRACK
		  // {: RESULT = method; :} Lista de Métodos 
		  | SliceType : slice
		  {: RESULT = slice; :}
		   ;

StructType ::= STRUCT LBRACK FieldDeclList RBRACK ;

ArrayType ::= LSBRACK Expression RSBRACK Type ;

SliceType ::= LSBRACK RSBRACK Type ;

FieldDeclList ::= FieldDecl SEMICOLON FieldDeclList
				| ;

FieldDecl ::=  ID Type
			 | ID
			 | TIMES ID ;			 

MethodSpecList ::= MethodSpec : method SEMICOLON MethodSpecList : listMethod
				{: 
					listMethod.add(0,method);				
					RESULT = listMethod;
				 :}
				| {: RESULT = new LinkedList<>(); :};

MethodSpec ::= ID :id Signature : sig
				{: RESULT = new MethodSpec(id,sig); :}
			 | ID :id
			 	{: RESULT = new MethodSpec(id,null); :}
			 ;

Signature ::= Parameters 
            | Parameters Resul ;
	            
Resul ::= Parameters
	    | Type ;
    
Parameters ::= LPAR RPAR
			 | LPAR ParameterList RPAR
			 | LPAR TypeList RPAR ;

ParameterList ::= ParameterDeclList
				| ID DOTDOTDOT Type
				| ID DOTDOTDOT Type COMMA ;

ParameterDeclList ::= IdentifierList Type COMMA ParameterDeclList 
				   | IdentifierList Type COMMA
				   | IdentifierList Type
				   | IdentifierList Type COMMA ID DOTDOTDOT Type COMMA
				   | IdentifierList Type COMMA ID DOTDOTDOT Type ;

TypeList ::=  Types
			| DOTDOTDOT Type COMMA
			| DOTDOTDOT Type
		;

Types ::=  ID COMMA Types
		 | ID COMMA DOTDOTDOT Type COMMA
		 | ID COMMA DOTDOTDOT Type
         | ID COMMA
         | ID
         | TypeLit COMMA Types
		 | TypeLit COMMA DOTDOTDOT Type COMMA
		 | TypeLit COMMA DOTDOTDOT Type
         | TypeLit COMMA
         | TypeLit ;

IdentifierList ::= ID:nm COMMA IdentifierList  : ids
				{: ids.add(0,nm);
					RESULT = ids;
				:}
				 | ID : nm
				 {:	
					List name = new LinkedList<String>();
					name.add(nm);				
					RESULT = name;
				 :}
				  ;

ConstDecl ::=  CONST IdentifierList : ids // Professor que fez
			{: List<ConstDecl> constDecls = new LinkedList<>(); 
			   for (String id: ids)
					constDecls.add(new ConstDecl(id, null, null));
				RESULT = constDecls;
			:}
			 | CONST IdentifierList : ids ASSIGN ExpressionList : exps
			 {:
				List<ConstDecl> constDecls = new LinkedList<>();
				Iterator<String> idIt = ids.iterator();
				Iterator<Expression> expIt = exps.iterator();
				while ( idIt.hasNext() && expIt.hasNext() )
					constDecls.add( new ConstDecl(idIt.next(), null, expIt.next()));
				if (idIt.hasNext() || expIt.hasNext())
					//Error.report("******");
			    RESULT = constDecls;
			 :}
			 | CONST IdentifierList : ids Type: type ASSIGN ExpressionList : exps 
			 {:
				List<ConstDecl> constDecls = new LinkedList<>();
				Iterator<String> idIt = ids.iterator();				
				Iterator<Expression> expIt = exps.iterator();
				while ( idIt.hasNext() && expIt.hasNext() )
					constDecls.add( new ConstDecl(idIt.next(), type, expIt.next()));
				if (idIt.hasNext() || expIt.hasNext())
					//Error.report("******");
			    RESULT = constDecls;
			 :}
			 ;


ExpressionList ::= ExpressionList COMMA Expression 
				 | Expression;

Expression ::= Expression PLUS Expression
			 | Expression MINUS Expression
			 | Expression TIMES Expression
			 | Expression DIV Expression
			 | Expression LT Expression
			 | Expression EQ Expression
			 | Expression AND Expression 
			 | UnaryExpr ;			 

UnaryExpr ::= PrimaryExpr
			| unary_op UnaryExpr ;

unary_op ::= PLUS | MINUS | EXCL | TIMES ;

PrimaryExpr ::= Operand
			  | PrimaryExpr DOT ID
			  | PrimaryExpr LSBRACK Expression RSBRACK
			  | PrimaryExpr LSBRACK Slice RSBRACK
			  | PrimaryExpr LPAR Arguments RPAR
			  | PrimaryExpr LPAR RPAR ;

Slice ::=  Expression  COLON  Expression 
	     | Expression COLON
	     | COLON Expression
	     | COLON
	     | Expression COLON Expression COLON Expression
	     | COLON Expression COLON Expression ;

Arguments ::= ExpressionList VariadicCommaOp ;
/*
			| TypeLit1 COMMA ExpressionList VariadicCommaOp // with Type is Ambbiguous
			| TypeLit1 VariadicCommaOp
			| TIMES Type COMMA ExpressionList VariadicCommaOp // with Type is Ambbiguous
			| TIMES Type VariadicCommaOp; //with Type is ambiguous
//btw, Type is correct here? The documentation says nothing about this. */
/**** TIRAMOS Type como primeiro argumento ***********/

VariadicCommaOp ::= DOTDOTDOT
	 | COMMA
	 | DOTDOTDOT COMMA
	 | ;

Operand ::= INT_NUMBER
		  | FLOAT_NUMBER
		  | TRUE
		  | FALSE
		  | CompositeLit
		  | FUNC Function 
		  //| MethodExpr
		  | LPAR Expression RPAR 
		  
		  ;

CompositeLit ::= LiteralType LiteralValue;

LiteralType ::= StructType
			  | ArrayType
			  | LSBRACK DOTDOTDOT RSBRACK Type
			  | SliceType
			   ;
			  
LiteralValue ::= LBRACK RBRACK
			   | LBRACK ElementList RBRACK ;

ElementList ::= KeyedElement COMMA ElementList
			  | KeyedElement 
			  | KeyedElement COMMA ;

			  
KeyedElement ::=  Element
			 	| Element COLON Element ;
			 	
Element ::= Expression
		  | LiteralValue ;

/*
MethodExpr ::= ReceiverType DOT ID ;
*/
//**** MethodExpr will be solved at the static semantics

ReceiverType ::= ID 
			   | LPAR TIMES ID LPAR
			   | LPAR ReceiverType RPAR ;

VarDecl ::= VAR VarSpec : varDecl // eu que fiz
			{:				
				RESULT = varDecl; 
			:}  
		  | VAR  LPAR VarSpecList  : varDecls RPAR // eu que fiz
		    {:				
				RESULT = varDecls; 
			:} 
		    ;
		  
VarSpecList ::= VarSpecList : varDecls1 VarSpec : varDecls2 SEMICOLON // professor que fez
				{: varDecls1.addAll(varDecls2); 
				   RESULT = varDecls1; :}  
			  | {: RESULT = new LinkedList<>(); :} 
			  ; 

VarSpec ::= IdentifierList : ids Type : type // professor que fez
			{: List<VarDecl> varDecls = new LinkedList<>(); 
			   for (String id: ids)
					varDecls.add(new VarDecl(id, type, null));
			   RESULT = varDecls;
			:}
		  | IdentifierList : ids ASSIGN ExpressionList : exps
		  {:
		  		List<VarDecl> varSpec = new LinkedList<>();
				Iterator<String> idIt = ids.iterator();
				Iterator<Expression> expIt = exps.iterator();
				while(idIt.hasNext() && expIt.hasNext())
					varSpec.add(new VarDecl(idIt.next(),null,expIt.next()));
				
				if(idIt.hasNext() || expIt.hasNext())
					System.out.println("ERRO  de Atribuição");
		  :}
		  | IdentifierList :ids Type : type ASSIGN ExpressionList : exps 
		  {:
		  List<VarDecl> varSpec = new LinkedList<>();
				Iterator<String> idIt = ids.iterator();
				Iterator<Expression> expIt = exps.iterator();
				while(idIt.hasNext() && expIt.hasNext())
					varSpec.add(new VarDecl(idIt.next(),type,expIt.next()));
				
				if(idIt.hasNext() || expIt.hasNext())
					System.out.println("ERRO  de Atribuição");
		  :}
		  ;

FunctionDecl ::= FUNC ID Function ;

Function ::= Signature Block ;

Block ::= LBRACK StatementList RBRACK;

StatementList ::= Statement SEMICOLON StatementList
				| ;

MethodDecl ::= FUNC LPAR ID ReceiverType RPAR ID Function ;

Statement ::= Declaration
			| SimpleStmt
			| RETURN 
			| RETURN ExpressionList
			| Block
			| IfStmt
			| ForStmt ;

SimpleStmt ::= Expression
/*// Se desejarem adicionar incrementos
		     | Expression PLUSPLUS
			 | Expression MINUSMINUS  */
			 | ExpressionList ASSIGN ExpressionList 
			 | /*IdentifierList*/ ExpressionList DASSIGN ExpressionList
			 | ; //EmptyStmt

IfStmt ::= IF SimpleStmt SEMICOLON Expression Block ElseOpt
		 | IF Expression Block ElseOpt;

ElseOpt ::= ELSE IfStmt
		  | ELSE Block 
		  |;

ForStmt ::= FOR Expression Block
		  | FOR SimpleStmt SEMICOLON SimpleStmt SEMICOLON SimpleStmt Block
		  | FOR RANGE Expression Block
		  | FOR /*IdentifierList*/ ExpressionList DASSIGN RANGE Expression Block
		  | FOR ExpressionList ASSIGN RANGE Expression Block;

// ~~ CUP-ECLIPSE:CONFLICT-RES-RR ~~ 
 // After this the order of productions matters

//Separated and moved by CUP Eclipse plugin
Operand ::=  ID;

//Separated and moved by CUP Eclipse plugin
LiteralType ::=  ID;



